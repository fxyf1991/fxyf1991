<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于js的冒泡--新手踩坑案例]]></title>
    <url>%2F2018%2F01%2F05%2Fbubble%2F</url>
    <content type="text"><![CDATA[先通过一段html代码了解各个div的从属关系123456&lt;div id='wrapper' class="wrapper"&gt; &lt;button id="clickMe"&gt;点我&lt;/button&gt; &lt;div id='popover' class="popover"&gt; 浮层 &lt;/div&gt;&lt;/div&gt; 要实现的功能是 通过button按钮点击后打开浮层 采用对button添加监听事件，默认隐藏浮层，在用户点击后展示浮层。 点击页面空白区域关闭浮层实现过程如下所示 1. 监听body首先考虑对body对象添加监听，内容为点击后隐藏浮层。发现无效后通过对body添加边框看到body高度是根据其内容变化的，所以只占屏幕上方很小一部分。 2. 监听document 同样无效。经分析，在冒泡阶段先触发按钮事件，但因同时存在对document的监听，紧接着触发document监听，所以仍然无法显示图层。 进一步思考后，对wrapper添加e.stopPropagation，即停止传播，由此可阻断冒泡，即可实现上述功能。 123456789clickMe.addEventListener('click', function(e)&#123; popover.style.display = 'block'&#125;)wrapper.addEventListener('click', function(e)&#123; e.stopPropagation()&#125;)document.addEventListener('click', function()&#123; popover.style.display = 'none'&#125;) 3. 以上虽然可实现需求，但添加的监听器过多，考虑减少内存的使用，可进行优化：将对document的监听全部添加到click事件的内部，并使用one方法只监听一次点击事件。123456789$(clickMe).on('click', function() &#123; $(popover).show() $(document).one('click', function() &#123; $(popover).hide() &#125;)&#125;)$(wrapper).on('click', function(e)&#123; e.stopPropagation()&#125;) 需注意，在3中若删除阻断，仍会出现bug，若执意删除，则需更改代码如下：12345678$(clickMe).on('click', function() &#123; $(popover).show() setTimeout(function() &#123; $(document).one('click', function() &#123; $(popover).hide() &#125;) &#125;, 0)&#125;) 上述代码中，将document监听放在setTimeout函数中，这里的setTimeout作用在于让其中的内容尽快执行而不是立即执行，若不添加则在button被点击之后会立即调用show和监听，此时会立即对popover绑定hide，在冒泡阶段便会依序执行show和hide，造成bug。]]></content>
      <tags>
        <tag>冒泡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个简单的 jQuery 的 API]]></title>
    <url>%2F2017%2F05%2F11%2Ftt%2F</url>
    <content type="text"><![CDATA[问题如下123456789window.jQuery = ???window.$ = jQueryvar $div = $(&apos;div&apos;)$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red$div.setText(&apos;hi&apos;) // 可将所有 div 的 textContent 变为 hi 整体思路如下我们考虑构造出一个新的函数，返回一个新的对象，该对象包含addClass和setText两个属性，之后便可以使用jQuery构造一个新的node（即$div）。在此之上，便可以使用$div调用addClass和setText两个属性。 addClass() 实现思路 使用document.querySelectorAll这个API获取当前所有div标签，返回一个nodeList 遍历nodeList中的所有div，给每个div加上相应的class setText() 实现思路 使用document.querySelectorAll这个API获取当前所有div标签，返回一个nodeList 遍历nodeList中的所有div，将每个div的内容通过textContent方法设置为hi 其中，？？？部分具体实现如下1234567891011121314151617function(node) &#123; return &#123; addClass: function (ccc) &#123; var x = document.querySelectorAll(node) for (let i = 0; i &lt; x.length; i++) &#123; x[i].classList.add(ccc) &#125; &#125;, setText: function (text) &#123; var x = document.querySelectorAll(node) for (let i = 0; i &lt; x.length; i++) &#123; x[i].textContent = text &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
